# 10. Message Authentication Codes

The challenge of CCA-secure encryption is dealing with ciphertexts that were generated by an adversary. Imagine there was a way to “certify” that a ciphertext was not adversarially generated — *i.e.,* it was generated by someone who knows the secret key. We could include such a certification in the ciphertext, and the Dec algorithm could raise an error if it asked to decrypt something with invalid certification.

What we are asking for is not to **hide** the ciphertext but to **authenticate** it: to ensure that it was generated by someone who knows the secret key. The tool for the job is called a **message authentication code**. One of the most important applications of a message authentication code is to transform a CPA-secure encryption scheme into a CCA-secure one.

As you read this chapter, keep in mind that privacy and authentication are indeed different properties. It is possible to have one or the other or indeed both simultaneously. But one does not imply the other, and it is crucial to think about them separately.

## 10.1 Definition

A MAC is like a signature that can be added to a piece of data, which certifies that someone who knows the secret key attests to this particular data. In cryptography, the term “signature” means something specific, and slightly different than a MAC. Instead of calling the output of a MAC algorithm a signature, we call it a “tag” (or, confusingly, just “a MAC”).

Our security requirement for a MAC scheme is that only someone with the secret key can generate a valid tag. To check whether a tag is valid, you just recompute the tag for a given message and see whether it matches the claimed tag. This implies that both generating and verifying a MAC tag requires the secret key.

**Definition 10.1 (MAC scheme)**

*A **message authentication code (MAC) scheme** for message space $\mathcal{M}$ consists of the following algorithms:*

 - KeyGen: *samples a key.*
 - MAC: *takes a key k and message $m \in \mathcal{M}$ as input, and outputs a **tag** t . The MAC algorithm is deterministic.*


### How to Think About Authenticity Properties

Every security definition we’ve seen so far is about hiding information, so how do we make a formal definition about authenticity?

Before we see the security definition for MACs, let’s start with a much simpler (potentially obvious?) statement: “an adversary should not be able to guess a uniformly chosen $\lambda$-bit value.” We can formalize this idea with the following two libraries:

$$
\def\arraystretch{1.5}
\begin{array}{|l|} \hline
\qquad\mathcal{L}_{\text{left}} \\ \hline
r \leftarrow \{\textcolor{brown}{0}, \textcolor{brown}{1}\}^{\lambda} \\
\underline{\text{GUESS}(g):} \\
\quad \text{return } g \overset{?}{=} r \\ \hline
\end{array}
\qquad
\begin{array}{|l|} \hline
\qquad\mathcal{L}_{\text{right}} \\ \hline
\underline{\text{GUESS}(g):} \\
\quad \text{return } \texttt{fasle} \\ \hline
\end{array}
$$

The left library allows the calling program to attempt to guess a uniformly chosen “target” string. The right library doesn’t even bother to verify the calling program’s guess — in fact it doesn’t even bother to sample a random target string!

The GUESS subroutines of these libraries give the same output on nearly all inputs. There is only one input $r$ on which they disagree. If a calling program can manage to find the value $r$, then it can easily distinguish the libraries. Therefore, by saying that these libraries are indistinguishable, we are really saying that **it’s hard for an adversary to find/generate this special value!** That’s the kind of property we want to express.

Indeed, in this case, an adversary who makes $q$ queries to the GUESS subroutine achieves an advantage of at most $q/2^{\lambda}$. For polynomial-time adversaries, this is a negligible advantage (since $q$ is a polynomial function of $\lambda$).

More generally, suppose we have two libraries, and a subroutine in one library checks some condition (and could return either $\texttt{true}$ or $\texttt{false}$), while in the other library this subroutine always returns $\texttt{false}$. If the two libraries are indistinguishable, the calling program can’t tell whether the library is actually checking the condition or always saying $\texttt{false}$. This means it must be very hard to find an input for which the “correct” answer is $\texttt{true}$.

### The MAC Security Definition

We want to say that only someone who knows the secret key can come up with valid MAC tags. In other words, the adversary cannot come up with valid MAC tags.

Actually, that property is not quite enough to be useful. A more useful property is: *even if the adversary knows valid MAC tags* corresponding to various messages, she cannot produce a valid MAC tag for a *different* message. We call it a **forgery** if the adversary can produce a “new” valid MAC tag.

To translate this security property to a formal definition, we define two libraries that allow the adversary to request MAC tags on chosen messages. The libraries also provide a mechanism to let the adversary *check* whether it has successfully found a forgery (since there is no way of checking this property without the secret key). One library will actually perform the check, and the other library will simply assume that forgeries are impossible.
The two libraries are different only in how they behave when the adversary calls this verification subroutine on a forgery. By demanding that the two libraries be indistinguishable, we are actually demanding that it is difficult for the calling program to generate a forgery.

**Definition 10.2 (MAC security)**

*Let $\Sigma$ be a MAC scheme. We say that $\Sigma$ is a* **secure MAC** *if $\mathcal{L}^{\Sigma}_{\text{mac-real}} \approx \mathcal{L}^{\Sigma}_{\text{mac-fake}}$, where:*

$$
\def\arraystretch{1.5}
\begin{array}{|l|} \hline
\qquad\qquad\mathcal{L}^{\Sigma}_{\text{mac-real}} \\ \hline
k \leftarrow \Sigma.\text{KeyGen} \\
\underline{\text{GETTAG}(m \in \Sigma.\mathcal{M}):} \\
\quad \text{return } \Sigma.\text{MAC}(k,m) \\ 
\underline{\text{CHECKTAG}(m \in \Sigma.\mathcal{M},t):} \\
\quad \text{return } t \overset{?}{=} \Sigma.\text{MAC}(k,m) \\ \hline
\end{array}
\qquad
\begin{array}{|l|} \hline
\qquad\qquad\mathcal{L}^{\Sigma}_{\text{mac-fake}} \\ \hline
k \leftarrow \Sigma.\text{KeyGen} \\
\colorbox{Yellow}{$\mathcal{T} := \empty$} \\
\underline{\text{GETTAG}(m \in \Sigma.\mathcal{M}):} \\
\quad t := \Sigma.\text{MAC}(k,m) \\ 
\quad \colorbox{Yellow}{$\mathcal{T} :=  \mathcal{T} \ \cup \{(m,t)\}$}    \\
\quad \text{return } t \\
\underline{\text{CHECKTAG}(m \in \Sigma.\mathcal{M},t):} \\
\quad \text{return } \colorbox{Yellow}{$(m,t) \overset{?}{\in}\mathcal{T} $ }\\ \hline
\end{array}
$$

Discussion:

 - The adversary can see valid tags of chosen messages, from the GETTAG subroutine. However, these tags shouldn’t count as a successful forgery. The way this is enforced is in the CHECKTAG subroutine of $\mathcal{L}_{\text{mac-fake}}$ — instead of always responding $\texttt{false}$, it gives the correct answer ($\texttt{true}$) for any tags generated by GETTAG.
 
     In order for the two libraries to behave differently, the adversary must call CHECKTAG on input $(m, t)$ such that $m$ was never used as an argument to GETTAG (so that $\mathcal{L}_{\text{mac-fake}}$ responds $\texttt{false}$) but where the tag is actually correct (so that $\mathcal{L}_{\text{mac-real}}$ responds $\texttt{true}$).
 - The adversary can successfully distinguish if it finds *any* forgery — a valid MAC tag of *any* “fresh” message. The definition doesn’t care whether it’s the tag of any particular *meaningful* message.


### MAC Applications
Although MACs are less embedded in public awareness than encryption, they are extremely useful. A frequent application of MACs is to store some information in an untrusted place, where we don’t intend to *hide* the data, only ensure that the data is not changed.

 - A **browser cookie** is a small piece of data that a webserver stores in a user’s web browser. The browser presents the cookie data to the server upon each request.
Imagine a webserver that stores a cookie when a user logs in, containing that user’s account name. What stops an attacker from modifying their cookie to contain a different user’s account name? Adding a MAC tag of the cookie data (using a key known only to the server) ensures that such an attack will not succeed. The server can trust any cookie data whose MAC tag is correct.
 - When Alice initiates a network connection to Bob, they must perform a **TCP handshake:**


 1. Alice sends a special SYN packet containing her initial sequence number $A$. In TCP, all packets from Alice to Bob include a sequence number, which helps the parties detect when packets are missing or out of order. It is important that the initial sequence number be random, to prevent other parties from injecting false packets.
2. Bob sends a special SYN+ACK packet containing $A+1$ (to acknowledge Alice’s $A$ value) and the initial sequence number $B$ for his packets.
3. Alice sends a special ACK packet containing $B + 1$, and then the connection is established.

When Bob is waiting for step 3, the connection is considered “half-open.” While waiting, Bob must remember $B$ so that he can compare to the $B + 1$ that Alice is supposed to send in her final ACK. Typically the operating system allocates only a very limited amount of resources for these half-open connections.

In the past, it was possible to perform a denial of service attack by starting a huge number of TCP connections with a server, but never sending the final ACK packet. The server’s queue for half-open connections fills up, which prevents other legitimate connections from starting.

A clever backwards-compatible solution to this problem is called **SYN cookies**. The idea is to let Bob choose his initial sequence number $B$ to be a MAC of the client’s IP address, port number, and some other values. Now there is nothing to store for half-open connections. When Alice sends the final ACK of the handshake, Bob can recompute the initial sequence number from his MAC key.

These are all cases where the person who *generates* the MAC is the same person who later *verifies* the MAC. You can think of this person as choosing not to store some information, but rather leaving the information with someone else as a “note to self.”

There are other useful settings where one party generates a MAC while the other verifies.

 - In **two-factor authentication**, a user logs into a service using *something they know (e.g.,* a password) and *something they have (e.g.,* a mobile phone). The most common two-factor authentication mechanism is called *timed one-time passwords (TOTP).* When you (as a user) enable two-factor authentication, you generate a secret key $k$ and store it both on your phone and with the service provider. When you wish to log in, you open a simple app on your phone which computes $p =$ MAC$(k,T)$, where $T$ is the current date $+$ time (usually rounded to the nearest 30 seconds). The value $p$ is the “timed one-time password.” You then log into the service using your usual (long-term) password and the one-time password $p$. The service provider has $k$ and also knows the current time, so can verify the MAC $p$.

    From the service provider’s point of view, the only other place $k$ exists is in the phone of this particular user. Intuitively, the only way to generate a valid one-time password at time $T$ is to be in posession of this phone at time $T$ . Even if an attacker sees both your long-term and one-time password over your shoulder, this does not help him gain access to your account in the future (well, not after 30 seconds in the future).


## $\star$ 10.2 A PRF is a MAC

The definition of a PRF says (more or less) that even if you’ve seen the output of the PRF on several chosen inputs, all other outputs look independently & uniformly random. Furthermore, uniformly chosen values are hard to guess, as long as they are sufficiently long (e.g., $\lambda$ bits).

In other words, after seeing some outputs of a PRF, any other PRF output will be hard to guess. This is exactly the intuitive property we require from a MAC. And indeed, we will prove in this section that a PRF is a secure MAC. While the claim makes intuitive sense, proving it formally is a little tedious. This is due to the fact that that in the MAC security game, the adversary can make many verification queries CHECKTAG$(m, t)$ *before* asking to see the correct MAC of $m$. Dealing with this event is the source of all the technical difficulty in the proof.

We start with a technical claim that captures the idea that “if you can blindly guess at uniformly chosen values and can also ask to see the values, then it is hard to guess a random value before you have seen it.”

**Claim 10.3**
*The following two libraries are indistinguishable:*

$$
\def\arraystretch{1.5}
\begin{array}{|l|} \hline
\qquad\qquad\qquad\mathcal{L}_{\text{guess-L}} \\ \hline
T := \text{empty assoc. array} \\
\underline{\text{GUESS}(m \in \{\textcolor{brown}{0},\textcolor{brown}{1}\}^{in}, g \in \{\textcolor{brown}{0},\textcolor{brown}{1}\}^{\lambda} ):} \\
\quad \text{if } T[m] \text{ undefined:} \\ 
\qquad T[m] \leftarrow \{\textcolor{brown}{0},\textcolor{brown}{1}\}^{\lambda} \\
\quad \text{return } g \overset{?}{=} T[m] \\
\underline{\text{REVEAL}(m \in \{\textcolor{brown}{0},\textcolor{brown}{1}\}^{in}):} \\
\quad \text{if } T[m] \text{ undefined:} \\ 
\qquad T[m] \leftarrow \{\textcolor{brown}{0},\textcolor{brown}{1}\}^{\lambda} \\
\quad \text{return }  T[m] \\ \hline
\end{array}
\qquad
\begin{array}{|l|} \hline
\qquad\qquad\qquad\mathcal{L}_{\text{guess-R}} \\ \hline
T := \text{empty assoc. array} \\
\underline{\text{GUESS}(m \in \{\textcolor{brown}{0},\textcolor{brown}{1}\}^{in}, g \in \{\textcolor{brown}{0},\textcolor{brown}{1}\}^{\lambda} ):} \\
//\ \textit{returns false if T$[$m$]$ undefined} \\ \\
\quad \text{return } g \overset{?}{=} T[m] \\
\underline{\text{REVEAL}(m \in \{\textcolor{brown}{0},\textcolor{brown}{1}\}^{in}):} \\
\quad \text{if } T[m] \text{ undefined:} \\ 
\qquad T[m] \leftarrow \{\textcolor{brown}{0},\textcolor{brown}{1}\}^{\lambda} \\
\quad \text{return }  T[m] \\ \hline
\end{array}
$$

Both libraries maintain an associative array $T$ whose values are sampled uniformly the first time they are needed. Calling programs can try to guess these values via the GUESS subroutine, or simply learn them via REVEAL. Note that the calling program can call GUESS$(m, \cdot)$ both *before and after* calling REVEAL$(m)$.

Intuitively, since the values in $T$ are $\lambda$ bits long, it should be hard to guess $T[m]$ before calling REVEAL$(m)$. That is exactly what we formalize in $\mathcal{L}_{\text{guess-R}}$. In fact, this library doesn’t bother to even choose $T[m]$ until REVEAL$(m)$ is called. All calls to GUESS$(m, \cdot)$ made before the first call to REVEAL$(m)$ will return $\texttt{false}$.

**Proof** 
Let $q$ be the number of queries that the calling program makes to GUESS. We will show that the libraries are indistinguishable with a hybrid sequence of the form:

$$
\mathcal{L}_{\text {guess-L}} \equiv \mathcal{L}_{\text {hyb-} 0} \approx \mathcal{L}_{\text {hyb-} 1} \approx \cdots \approx \mathcal{L}_{\text {hyb-} q} \equiv \mathcal{L}_{\text {guess-R}}
$$

The $h$th hybrid library in the sequence is defined as:

$$
\def\arraystretch{1.5}
\begin{array}{|l|} \hline
\qquad\qquad\qquad\mathcal{L}_{\text{hyp-}h} \\ \hline
count := 0 \\
T := \text{empty assoc. array} \\
\underline{\text{GUESS}(m , g):} \\
\quad count := count + 1 \\
\quad \text{if } T[m] \text{ undefined and } count > \colorbox{Lightgray}{$h$} : \\ 
\qquad T[m] \leftarrow \{\textcolor{brown}{0},\textcolor{brown}{1}\}^{\lambda} \\
\quad \text{return } g \overset{?}{=} T[m] \\
\quad //\ \textit{returns\ false\ if\ T$[$m$]$\ undefined} \\
\underline{\text{REVEAL}(m):} \\
\quad \text{if } T[m] \text{ undefined:} \\ 
\qquad T[m] \leftarrow \{\textcolor{brown}{0},\textcolor{brown}{1}\}^{\lambda} \\
\quad \text{return }  T[m] \\ \hline
\end{array}
$$

This hybrid library behaves like $\mathcal{L}_{\text {guess-R }}$ for the first $h$ queries to GUESS, in the sense that it will always just return false when $T[m]$ is undefined. After $h$ queries, it will behave like $\mathcal{L}_{\text {guess-L }}$ by actually sampling $T[m]$ in these cases.

In $\mathcal{L}_{\text {hyb-} 0}$, the clause "$count > \colorbox{lightgrey}0$ " is always true so this clause can be removed from the if-condition. This modification results in $\mathcal{L}_{\text {guess-L }},$ so we have $\mathcal{L}_{\text {guess-L}} \equiv \mathcal{L}_{\text {hyb-} 0}$.

In $\mathcal{L}_{\text {hyb-} q}$, the clause "$count >\colorbox{lightgrey}{\textit{q}}$ "in the if-statement is always false since the calling program makes only $q$ queries. Removing the unreachable if-statement it results in $\mathcal{L}_{\text {guess-R }},$ so we have $\mathcal{L}_{\text {guess-R}} \equiv \mathcal{L}_{\text {hyb- } q}$ 

It remains to show that $\mathcal{L}_{\text {hyb- } h} \approx \mathcal{L}_{\text {hyb- }(h+1)}$ for all $h$. We can do so by rewriting these two libraries as follows:

$$
\def\arraystretch{1.5}
\begin{array}{|l|} \hline
\qquad\qquad\qquad\mathcal{L}_{\text{hyp-}h} \\ \hline
count := 0 \\
T := \text{empty assoc. array} \\
\underline{\text{GUESS}(m , g):} \\
\quad count := count + 1 \\
\quad \text{if } T[m] \text{ undefined and } count > \colorbox{lightgrey}{$h$
} : \\ 
\qquad T[m] \leftarrow \{\textcolor{brown}{0},\textcolor{brown}{1}\}^{\lambda} \\
\qquad \colorbox{Yellow} {if \textit{g = T}[m] and \textit{count = \colorbox{Lightgrey}h} + 1:} \\
\qquad\quad \colorbox{Yellow}{\text{bad} := 1} \\
\quad \text{return } g \overset{?}{=} T[m] \\
\quad //\ \textit{returns\ false\ if\ T$[$m$]$\ undefined} \\
\underline{\text{REVEAL}(m):} \\
\quad \text{if } T[m] \text{ undefined:} \\ 
\qquad T[m] \leftarrow \{\textcolor{brown}{0},\textcolor{brown}{1}\}^{\lambda} \\
\quad \text{return }  T[m] \\ \hline
\end{array}
\qquad
\begin{array}{|l|} \hline
\qquad\qquad\qquad\mathcal{L}_{\text{hyp-}(h+1)} \\ \hline
count := 0 \\
T := \text{empty assoc. array} \\
\underline{\text{GUESS}(m , g):} \\
\quad count := count + 1 \\
\quad \text{if } T[m] \text{ undefined and } count > \colorbox{lightgrey}{$h$} : \\ 
\qquad T[m] \leftarrow \{\textcolor{brown}{0},\textcolor{brown}{1}\}^{\lambda} \\
\qquad  \colorbox{Yellow}{if  $g = T$[m] and $count = \colorbox{lightgrey}{$h$}$ + 1: }\\
\qquad\quad \text{bad} := 1; \text{ return } \texttt{false} \\
\quad \text{return } g \overset{?}{=} T[m] \\
\quad //\ \textit{returns\ false\ if\ T[m]\ undefined }\\
\underline{\text{REVEAL}(m):} \\
\quad \text{if } T[m] \text{ undefined:} \\ 
\qquad T[m] \leftarrow \{\textcolor{brown}{0},\textcolor{brown}{1}\}^{\lambda} \\
\quad \text{return }  T[m] \\ \hline
\end{array}
$$

The library on the left is equivalent to $\mathcal{L}_{\text{hyb}-h}$ since the only change is the highlighted lines, which don’t actually affect anything. In the library on the right, if $T[m]$ is undefined during the first $h + 1$ calls to GUESS, the subroutine will return false (either by avoiding the if-statement altogether or by triggering the highlighted lines). This matches the behavior of $\mathcal{L}_{\text{hyb-}(h + 1)}$, except that the library shown above samples the value $T[m]$ which in $\mathcal{L}_{\text{hyb-}(h + 1)}$ would not be sampled until the next call of the form GUESS$(m, \cdot)$ or REVEAL$(m)$. But the method of sampling is the same, only the timing is different. This difference has no effect on the calling program.

So the two libraries above are indeed equivalent to $\mathcal{L}_{\text{hyb-}h}$ and $\mathcal{L}_{\text{hyb-}(h + 1)}$. They differ only in code that is reachable when bad $= 1$. From Lemma 4.8, we know that these two libraries are indistinguishable if Pr[bad $= 1]$ is negligible. In these libraries there is only one chance to set bad $= 1$, and that is by guessing/predicting uniform $T[m]$ on the $(h+1)$th call to GUESS. This happens with probability $1/2^{\lambda}$, which is indeed negligible.

This shows that $\mathcal{L}_{\text{hyb-}h} \approx \mathcal{L}_{\text{hyb-}(h + 1)}$, and completes the proof. $\ \blacksquare$

We now return to the problem of proving that a PRF is a MAC.

**Claim 10.4** 
*Let $F$ be a secure PRF with input length in and output length out $= \lambda$. Then the scheme MAC$(k,m) = F (k,m)$ is a secure MAC for message space $\{\textcolor{brown}{0}, \textcolor{brown}{1}\}^{in}$.*

**Proof**
We show that $\mathcal{L}_{\text {mac-real }}^{F} \approx \mathcal{L}_{\text {mac-fake }}^{F},$ using a standard sequence of hybrids.

$$
\def\arraystretch{1.5}
\begin{array}{|l|} \hline
\quad\qquad\mathcal{L}^{F}_{\text{mac-real}} \\ \hline
k \leftarrow \{\textcolor{brown}{0}, \textcolor{brown}{1}\}^{\lambda} \\
\underline{\text{GETTAG}(m):} \\
\quad \text{return } F(k,m) \\ 
\underline{\text{CHECKTAG}(m,t):} \\
\quad \text{return } t \overset{?}{=} F(k,m) \\ \hline
\end{array}
\quad
\begin{array}{l}
\text{The starting point is the}\\
\text{$\mathcal{L}_{\text{mac-real}}$ library, with the}\\
\text{details of this MAC scheme}\\
\text{filled in}
\end{array}
$$

$$
\def\arraystretch{1.5}
\begin{array}{|l|} \hline
\underline{\text{GETTAG}(m):} \\
\quad \text{return} \colorbox{Yellow}{LOOKUP($m$)} \\ 
\underline{\text{CHECKTAG}(m,t):} \\
\quad \text{return } t \overset{?}{=} \colorbox{Yellow}{LOOKUP($m$)} \\ \hline
\end{array}
\diamond
\begin{array}{|l|} \hline
\quad\qquad\mathcal{L}^{F}_{\text{prf-real}} \\ \hline
k \leftarrow \{\textcolor{brown}{0}, \textcolor{brown}{1}\}^{\lambda} \\
\underline{\text{LOOKUP}(x):} \\
\quad \text{return } F(k,x) \\ \hline
\end{array}
\quad
\begin{array}{l}
\text{We have factored out the PRF}\\
\text{operations in terms of the library} \\
\text{$\mathcal{L}_{\text{prf-real}}$ from the PRF}\\
\text{security definition.}\\
\end{array}
$$

$$
\def\arraystretch{1.5}
\begin{array}{|l|} \hline
\underline{\text{GETTAG}(m):} \\
\quad \text{return LOOKUP} (m) \\ 
\underline{\text{CHECKTAG}(m,t):} \\
\quad \text{return } t \overset{?}{=} \text{LOOKUP}(m) \\ \hline
\end{array}
\diamond
\begin{array}{|l|} \hline
\quad\qquad\mathcal{L}^{F}_{\text{prf-rand}} \\ \hline
T := \text{empty assoc. array} \\
\underline{\text{LOOKUP}(x):} \\
\quad \text{if } T[x] \text{ undefined:} \\
\qquad T[x]\leftarrow \{\textcolor{brown}{0}, \textcolor{brown}{1}\}^{out} \\
\quad \text{return } T(x) \\ \hline
\end{array}
\quad
\begin{array}{l}
\text{We have applied the PRF-}\\
\text{security of $F$ and replaced} \\
\text{$\mathcal{L}_{\text{prf-real}}$ with $\mathcal{L}_{\text{prf-rand}}$.}\\
\end{array}
$$

$$
\def\arraystretch{1.5}
\begin{array}{|l|} \hline
\underline{\text{GETTAG}(m):} \\
\quad \text{return }\colorbox{Yellow}{REVEAL($m$) } \\ 
\underline{\text{CHECKTAG}(m,t):} \\
\quad \text{return }  \colorbox{Yellow}{GUESS($m,t$)} \\ \hline
\end{array}
\diamond
\begin{array}{|l|} \hline
\quad\qquad\mathcal{L}_{\text{guess-L}} \\ \hline
T := \text{empty assoc. array} \\
\underline{\text{GUESS}(m,g):} \\
\quad \text{if } T[m] \text{ undefined:} \\
\qquad T[m]\leftarrow \{\textcolor{brown}{0}, \textcolor{brown}{1}\}^\lambda \\
\quad \text{return } g\stackrel{?}{=}T[m]\\ 
\underline{\text{REVEAL}(m):}\\
\quad \text{if}\ T[m]\ \text{undefined:}\\
\qquad T[m]\leftarrow \{\textcolor{brown}{0},\textcolor{brown}{1}\}^\lambda\\
\quad \text{return}\ T[m]\\\hline
\end{array}
\quad
\begin{array}{l}
\text{We can express the previous}\\
\text{hybrid in terms of the $\mathcal{L}_{\text{guess-L}}$} \\
\text{library from Claim 10.3. The}\\
\text{change has no effect on the}\\
\text{calling program.} \\
\end{array}
$$

$$
\def\arraystretch{1.5}
\begin{array}{|l|} \hline
\underline{\text{GETTAG}(m):} \\
\quad \text{return REVEAL} (m) \\ 
\underline{\text{CHECKTAG}(m,t):} \\
\quad \text{return }  \text{GUESS}(m,t) \\ \hline
\end{array}
\diamond
\begin{array}{|l|} \hline
\quad\qquad\mathcal{L}_{\text{guess-R}} \\ \hline
T := \text{empty assoc. array} \\
\underline{\text{GUESS}(m,g):} \\
\quad \text{return } g\stackrel{?}{=}T[m]\\ 
\underline{\text{REVEAL}(m):}\\
\quad \text{if}\ T[m]\ \text{undefined:}\\
\qquad T[m]\leftarrow \{\textcolor{brown}{0},\textcolor{brown}{1}\}^\lambda\\
\quad \text{return}\ T[m]\\\hline
\end{array}
\quad
\begin{array}{l}
\text{We have applied Claim 10.3 to}\\
\text{ replace $\mathcal{L}^{F}_{\text{guess-L}}$ with $\mathcal{L}^{F}_{\text{guess-R}}$.} \\
\text{This involves simply removing}\\
\text{the if-statement from GUESS. }\\
\text{As a result, GUESS$(m,g)$ will return} \\
\text{$\mathtt{false}$ if $T[m]$ is undefined.} \\
\end{array}
$$

$$
\def\arraystretch{1.5}
\begin{array}{|l|} \hline
\colorbox{Yellow}{$\mathcal{T}:=\emptyset$} \\
\underline{\text{GETTAG}(m):} \\
\quad \colorbox{Yellow}{t:=\text{REVEAL} ($m$)} \\ 
\quad \colorbox{Yellow}{$\mathcal{T}:=\mathcal{T}\cup \{(m,t)\}$}\\
\quad \text{return}\ t\\
\underline{\text{CHECKTAG}(m,t):} \\
\quad \text{return }  \text{GUESS}(m,t) \\ \hline
\end{array}
\diamond
\begin{array}{|l|} \hline
\quad\qquad\mathcal{L}^{F}_{\text{guess-R}} \\ \hline
T := \text{empty assoc. array} \\
\underline{\text{GUESS}(m,g):} \\
\quad \text{return } g\stackrel{?}{=}T[m]\\ 
\underline{\text{REVEAL}(m):}\\
\quad \text{if}\ T[m]\ \text{undefined:}\\
\qquad T[m]\leftarrow \{\textcolor{brown}{0},\textcolor{brown}{1}\}^\lambda\\
\quad \text{return}\ T[m]\\\hline
\end{array}
\begin{array}{l}
\text{Extra bookkeeping information}\\
\text{is added, but not used} \\
\text{anywhere. There is no effect}\\
\text{on the calling program.}\\
\end{array}
$$

   

Consider the hybrid experiment above, and suppose the calling program makes a call to CHECKTAG $(m, t)$. There are two cases:
- Case 1 : there was a previous call to GETTAG $(m)$. In this case, the value $T[m]$ is defined in $\mathcal{L}_{\text {guess-R }}$ and $(m, T[m])$ already exists in $\mathcal{T}$. In this case, the result of $\operatorname{GUESS}(m, t)$ (and hence, of $\operatorname{CHECKTAG}(m, t))$ will be $t \stackrel{?}{=} T[m]$.

- Case 2: there was no previous call to GETTAG $(m)$. Then there is no value of the form $(m,\star)$ in $\mathcal{T}$.  Furthermore, $T[m]$ is undefined in $\mathcal{L}_{\text{guess-R}}$. The call to GUESS $(m,t)$ will return $\mathtt{false}$, and so will the call to CHECKTAG $(m,t)$ that we consider.

In both cases, the result of CHECKTAG $(m,t)$ is true **if and only if** $(m,t)\in\mathcal{T}$.

$$
\def\arraystretch{1.5}
\begin{array}{|l|} \hline
\mathcal{T}:=\emptyset\\
\underline{\text{GETTAG}(m):} \\
\quad t:=\text{REVEAL} (m) \\ 
\quad \mathcal{T}:=\mathcal{T}\cup \{(m,t)\}\\
\quad \text{return}\ t\\
\underline{\text{CHECKTAG}(m,t):} \\
\quad \text{return }  \colorbox{Yellow}{$(m,t)\stackrel{?}{\in}\mathcal{T}$} \\ \hline
\end{array}
\diamond
\begin{array}{|l|} \hline
\quad\qquad\mathcal{L}_{\text{guess-R}} \\ \hline
T := \text{empty assoc. array} \\
\underline{\text{GUESS}(m,g):} \\
\quad \text{return } g\stackrel{?}{=}T[m]\\ 
\underline{\text{REVEAL}(m):}\\
\quad \text{if}\ T[m]\ \text{undefined:}\\
\qquad T[m]\leftarrow \{\textcolor{brown}{0},\textcolor{brown}{1}\}^\lambda\\
\quad \text{return}\ T[m]\\\hline
\end{array}
\begin{array}{l}
\text{We have modified CHECKTAG}\\
\text{according to the discussion above.} \\
\end{array}
$$

$$
\def\arraystretch{1.5}
\begin{array}{|l|} \hline
\mathcal{T}:=\emptyset\\
\underline{\text{GETTAG}(m):} \\
\quad t:= \colorbox{Yellow}{$\text{LOOKUP} ($m$)$} \\ 
\quad \mathcal{T}:=\mathcal{T}\cup \{(m,t)\}\\
\quad \text{return}\ t\\
\underline{\text{CHECKTAG}(m,t):} \\
\quad \text{return }  (m,t)\stackrel{?}{\in}\mathcal{T} \\ \hline
\end{array}
\diamond
\begin{array}{|l|} \hline
\quad\qquad\mathcal{L}^{F}_{\text{prf-rand}} \\ \hline
T := \text{empty assoc. array} \\
\underline{\text{LOOKUP}(x):} \\
\quad \text{if}\ T[x]\ \text{undefined:}\\
\qquad T[x]\leftarrow \{\textcolor{brown}{0},\textcolor{brown}{1}\}^{out}\\
\quad \text{return}\ T[x]\\\hline
\end{array}
\begin{array}{l}
\text{In the previous hybrid, the GUESS}\\
\text{subroutine is never called. Removing} \\
\text{that unused subroutine and renaming} \\
\text{REVEAL to LOOKUP results in} \\
\text{the $\mathcal{L}_{\text{prf-ideal}}$ library from the PRF} \\
\text{security definition.} \\
\end{array}
$$

$$
\def\arraystretch{1.5}
\begin{array}{|l|} \hline
\mathcal{T}:=\emptyset\\
\underline{\text{GETTAG}(m):} \\
\quad t:=\text{LOOKUP} (m) \\ 
\quad \mathcal{T}:=\mathcal{T}\cup \{(m,t)\}\\
\quad \text{return}\ t\\
\underline{\text{CHECKTAG}(m,t):} \\
\quad \text{return }  (m,t)\stackrel{?}{\in}\mathcal{T} \\ \hline
\end{array}
\diamond
\begin{array}{|l|} \hline
\quad\qquad\mathcal{L}^{F}_{\text{prf-real}} \\ \hline
k\leftarrow \{\textcolor{brown}{0},\textcolor{brown}{1}\}^\lambda\\
\underline{\text{LOOKUP}(x):} \\
\quad \text{return}\ F(k,x)\\\hline
\end{array}
\begin{array}{l}
\text{We have applied the PRF security}\\
\text{of $F$ again, replacing $\mathcal{L}_{\text{prf-ideal}}$ with} \\
\text{$\mathcal{L}_{\text{prf-real}}$.}\\
\end{array}
$$

   

Inlining $\mathcal{L}_{\text {prf-real }}$ in the final hybrid, we see that the result is exactly $\mathcal{L}_{\text {mac-fake }}^{F} .$ Hence, we have shown that $\mathcal{L}_{\text {mac-real }}^{F} \approx \mathcal{L}_{\text {mac-fake }}^{F}$, which completes the proof.

### Discussion
**If PRFs are MACs, why do we even need a definition for MACs?** The simplest answer to this question is that the concepts of PRF and MAC are indeed different:
- Not every PRF is a MAC. **Only sufficiently long random values are hard to guess**, so only PRFs with long outputs (out $\geqslant \lambda)$ are MACs. It is perfectly reasonable to consider a PRF with short outputs.
- Not every MAC is a PRF. Just like not every encryption scheme has pseudorandom ciphertexts, not every MAC scheme has pseudorandom tags. Imagine taking a secure MAC scheme and modifying it as $\operatorname{MAC}^{\prime}(k, m)=\operatorname{MAC}(k, m) \|  \textcolor{Red}0^{\lambda}$. Adding $\textcolor{Red}{0}$s to every tag prevents the tags from looking pseudorandom, but does not make the tags any easier to guess. **Something doesn't have to be uniformly random in order to be hard to guess.**

It is true that in the vast majority of cases we will encounter MAC schemes with random tags, and PRFs with long outputs (out $\geqslant \lambda)$. But it is good practice to know whether you really need something that is *pseudorandom or hard to guess*.

## 10.3 MACs for Long Messages
Using a PRF as a MAC is useful only for short, fixed-length messages, since most PRFs that exist in practice are limited to such inputs. Can we somehow extend a PRF to construct a MAC scheme for long messages, similar to how we used block cipher modes to construct encryption for long messages?
### How NOT to do it
To understand the challenges of constructing a MAC for long messages, we first explore some approaches that *don't* work. The things that can go wrong in an insecure MAC are quite different in character to the things that can go wrong in a block cipher mode, so pay attention closely!

*Let $F$ be a PRF with *in* = *out* = $\lambda$. Below is a MAC approach for messages of length $2\lambda$. It is inspired by ECB mode, so you know it’s going to be a disaster:*

$$
\def\arraystretch{1.5}
\begin{array}{|l|} \hline
\underline{\text{ECBMAC}(k,m_1\|m_2):} \\
\quad t_1:=F(k,m_1) \\ 
\quad t_2:=F(k,m_2) \\ 
\quad \text{return}\ t_1\|t_2\\\hline
\end{array}
$$

*One problem with this approach is that, although the PRF authenticates each block $m_1,m_2$ individually, it does nothing to authenticate that $m_1$ is the first block but $m_2$ is the second one. Translating this observation into an attack, an adversary can ask for the MAC tag of $m_1\|m_2$ and then predict/forge the tag for $m_2\|m_1$:*

$$
\def\arraystretch{1.5}
\begin{array}{|l|} \hline
\qquad \qquad \qquad \quad\mathcal{A}:\\\hline
t_1\|t_2:=\text{GETTAG}(\textcolor{brown}{0}^\lambda\|\textcolor{brown}{1}^\lambda)\\
\text{return CHECKTAG}(\textcolor{brown}{1}^\lambda\|\textcolor{brown}{0}^\lambda,t_2\|t_1)\\\hline
\end{array}
$$

*When $\mathcal{A}$ is linked to $\mathcal{L}_{\text{mac-real}}$, it always return  $\mathit{true}$, since we can tell that $t_2\|t_1$ is indeed the valid tag for $\textcolor{brown}{1}^\lambda\|\textcolor{brown}{0}^\lambda$. When $\mathcal{A}$ is linked to $\mathcal{L}_{\text{mac-fake}}$, it always return  $\mathit{false}$, since the calling program never called GETTAG with input $\textcolor{brown}{1}^\lambda\|\textcolor{brown}{0}^\lambda$. Hence, $\mathcal{A}$ distinguishes the libraries with advantage 1.*

This silly MAC construction treats both $m_1$ and $m_2$ identically, and an obvious way to try to fix the problem is to treat the different blocks differently somehow:

**Example**
*Let $F$ be a PRF with in = $\lambda + 1$ and out = $\lambda$. Below is another MAC approach for messages of length 2$\lambda$:*

$$
\def\arraystretch{1.5}
\begin{array}{|l|} \hline
\underline{\text{ECB++MAC}(k,m_1\|m_2):}\\
\quad t_1:=F(k,\textcolor{brown}{0}\|m_1)\\
\quad t_2:=F(k,\textcolor{brown}{1}\|m_2)\\
\quad \text{return}\ t_1\|t_2\\\hline
\end{array}
$$

*This MAC construction does better, as it treats the two message blocks $m_1$ and $m_2$ differently. Certainly the previous attack of swapping the order of $m_1$ and $m_2$ doesn’t work anymore. (Can you see why?)*

*The construction authenticates (in some sense) the fact that $m_1$ is the first message block, and $m_2$ is the second block. However, this construction doesn’t authenticate **the fact that this particular $m_1$ and $m_2$ belong together**. More concretely, we can “mix and match” blocks of the tag corresponding to different messages:*

$$
\def\arraystretch{1.5}
\begin{array}{|l|} \hline
\qquad \qquad \qquad \mathcal{A}:\\\hline
\quad t_1\|t_2:=\text{GETTAG}(\textcolor{brown}{0}^{2\lambda})\\
\quad t'_1\|t'_2:=\text{GETTAG}(\textcolor{brown}{1}^{2\lambda})\\
\quad \text{return CHECKTAG}(\textcolor{brown}{0}^{\lambda}\|\textcolor{brown}{1}^{\lambda},t_1\|t'_2)\\\hline
\end{array}
$$
*In this attack, we combine the $t_1$ block from the First tag and the $t_2$ block from the second tag.*

We are starting to see the challenges involved in constructing a MAC scheme for long messages. A secure MAC should authenticate each message block, the order of the message blocks, and the fact that these *particular message blocks are appearing in a single message*. In short, it must authenticate the *entirety* of the message.

Think about how authentication is significantly different than privacy/hiding in this respect. At least for CPA security, we can hide an entire plaintext by hiding each individual piece of the plaintext separately (encrypting it with a CPA-secure encryption). Authentication is fundamentally different.

### How to do it: CBC-MAC
We have seen some insecure ways to construct a MAC for longer messages. Now let's see a secure way. A common approach to constructing a MAC for long messages involves the CBC block cipher mode.

**Construction 10.5 (CBC-MAC)**
*Let $F$ be a PRF with *in* $=$ *out* $=\lambda .$ CBC-MAC refers to the following MAC scheme:*

$$
\textcolor{red}{{\text{Image screenshot here}}}
$$

Unlike CBC encryption, CBC-MAC uses no initialization vector (or, you can think of it as using the all-zeroes IV), and it outputs only the last block.

**Theorem 10.6**

*If $F$ is a secure PRF with in $=$ out $=\lambda,$ then for any fixed $\ell, C B C-M A C$ is a secure MAC when used with message space $\mathcal{M}=\{\textcolor{brown}{0},\textcolor{brown}{1}\}^{\lambda \ell}$*

Pay close attention to the security statement. It says that if you only ever authenticate 4-block messages, CBC-MAC is secure. If you only ever authenticate 24 -block messages, CBC-MAC is secure. However, if you want to authenticate both 4 -block and 24 -block messages (*i.e.*, under the same key), then CBC-MAC is not secure. In particular, seeing the CBC-MAC of several 4-block messages allows an attacker to generate a forgery of a 24-block message. The exercises explore this property.

### More Robust CBC-MAC
If $\mathrm{CBC}-\mathrm{MAC}$ is so fragile, is there a way to extend it to work for messages of mixed lengths? One approach is called $\mathrm{ECBC}-\mathrm{MAC},$ and is shown below. It works by treating the last block differently - specifically, it uses an independent PRF key for the last block in the CBC chain.

**Construction 10.7 (ECBC-MAC)**
*Let $F$ be a PRF with in $=$ out $=\lambda .$ ECBC-MAC refers to the following scheme:*

$$
\textcolor{red}{{\text{Image screenshot here}}}
$$

**Theorem 10.8**
*If $F$ is a secure PRF with *in* = *out* = $\lambda$, then ECBC-MAC is a secure MAC for message space $\mathcal{M}=(\{\textcolor{brown}{0},\textcolor{brown}{1}\}^{\lambda})^*$.*

In other words, ECBC-MAC is safe to use with messages of any length (that is a multiple of the block length).

To extend ECBC-MAC to messages of *any* length (not necessarily a multiple of the block length), one can use a padding scheme as in the case of encryption.[^1]
[^1]: Note that if the message is already a multiple of the block length, then padding adds an extra block. There exist clever ways to avoid an extra padding block in the case of MACs, which we don’t discuss further.

## 10.4 Encrypt-Then-MAC
Our motivation for studying MACs is that they seem useful in constructing a CCA-secure encryption scheme. The idea is to add a MAC to a CPA-secure encryption scheme. The decryption algorithm can raise an error if the MAC is invalid, thereby ensuring that adversarially-generated (or adversarially-modified) ciphertexts are not accepted. There are several natural ways to combine a MAC and encryption scheme, but *not all are secure!* (See the exercises.) The safest way is known as encrypt-then-MAC:

**Construction 10.9 (Enc-then-MAC)**
*Let $E$ denote an encryption scheme, and $M$ denote a MAC scheme where $E . C \subseteq M . \mathcal{M}$ (i.e., the MAC scheme is capable of generating MACs of ciphertexts in the E scheme). Then let EtM denote the **encrypt-then-MAC** construction given below:*

$$
\def\arraystretch{1.5}
\begin{array}{|ll|}\hline
&\underline{\text{Enc}((k_e,k_m),m):}\\
\mathcal{K}=E.\mathcal{K}\times M.\mathcal{K} & \quad c:=E\text{.Enc}(k_e,m)\\
\mathcal{M}=E.\mathcal{M} & \quad t:=M.\text{MAC}(k_m,c)\\
C=E.C\times M.\mathcal{T} & \quad \text{return}\ (c,t)\\
\underline{\text{KeyGen:}} &\underline{\text{Dec}((k_e,k_m),(c,t)):}\\
\quad k_e\leftarrow \text{E.KeyGen} & \quad \text{if}\ t\neq M.\text{MAC}(k_m,c):\\
\quad k_m\leftarrow M.\text{KeyGen} & \qquad \text{return \textcolor{brown}{\texttt{err}}}\\
\quad \text{return}\ (k_e,k_m) & \quad \text{return}\ E.\text{Dec}(k_e,c)\\\hline
\end{array}
$$

Importantly, the scheme computes a MAC of the CPA ciphertext, and not of the plaintext! The result is a CCA-secure encryption scheme:

**Claim 10.10**
*If E has CPA security and M is a secure MAC, then EtM (Construction 10.9) has CCA security.*

**Proof**
As usual, we prove the claim with a sequence of hybrid libraries:

$$
\def\arraystretch{1.5}
\begin{array}{|l|}\hline
\qquad \qquad\mathcal{L}_{\text{cca-L}}^{EtM}\\\hline
\colorbox{Yellow}{$k_e\leftarrow E.\text{KeyGen}$} \\
\colorbox{Yellow}{$k_m\leftarrow M.\text{KeyGen}$}\\
S:=\emptyset\\
\underline{\text{EAVESDROP}(m_L,m_R):}\\
\quad \text{if}\ |m_L|\neq |m_R|\\
\qquad\text{return null}\\
\quad \colorbox{Yellow}{$c:=E.\text{Enc}(k_e,m_L)$}\\
\quad \colorbox{Yellow}{$t\leftarrow M.\text{MAC}(k_m,c)$}\\
\quad S:=S\cup\{\colorbox{Yellow}{($c,t$)}\}\\
\quad \text{return}\ \colorbox{Yellow}{($c,t$)}\\
\underline{\text{Dec}(c,t):}\\
\quad \text{if}\ (c,t)\in S\ \text{return null}\\
\quad \text{if}\ t\neq M.\text{MAC}(k_m,c):\\
\qquad \text{return \textcolor{brown}{err}}\\
\quad \text{return $E$.Dec}(k_e,c)\\\hline
\end{array}
\begin{array}{l}
\text{The starting point is $\mathcal{L}_{\text{cca-L}}^{EtM}$, shown here with the details of}\\
\text{the encrypt-then-MAC construction highlighted. Our goal is} \\
\text{to eventually swap $m_L$ with $m_R$. But the CPA security of $E$}\\
\text{should allow us to do just that, so what’s the catch?}\\
\\
\text{To apply the CPA-security of $E$, we must factor out the relevant} \\
\text{call to $E.$Enc in terms of the CPA library $\mathcal{L}_{\text{cpa-L}}^{E}$. This}\\
\text{means that $k_e$ becomes private to the $\mathcal{L}_{\text{cpa-L}}$ library. But $k_e$}\\
\text{is also used in the last line of the library as $E$.Dec$(k_e,c)$. The}\\
\text{$CPA$ security library for E provides no way to carry out such}\\
\text{$E$:Dec statements!}\\
\end{array}
$$

   

     

$$
\def\arraystretch{1.5}
\begin{array}{|l|}\hline
k_e\leftarrow E.\text{KeyGen}\\
S:=\emptyset\\
\underline{\text{EAVESDROP}(m_L,m_R):}\\
\quad \text{if}\ |m_L|\neq |m_R|\\
\qquad\text{return null}\\
\quad c:=E.\text{Enc}(k_e,m_L)\\
\quad t:=\colorbox{Yellow}{$\text{GETTAG}(c)$}\\
\quad S:=S\cup\{(c,t)\}\\
\quad \text{return}\ (c,t)\\
\underline{\text{Dec}(c,t):}\\
\quad \text{if}\ (c,t)\in S\\
\qquad \text{return null}\\
\quad \text{if}\ \colorbox{Yellow}{$\text{not CHECKTAG}(c,t)$}\\
\qquad \text{return \textcolor{brown}{err}}\\
\quad \text{return E.Dec}(k_e,c)\\\hline
\end{array}
\diamond
\begin{array}{|l|}\hline
\qquad \qquad\mathcal{L}_{\text{mac-real}}^M\\\hline
k_m\leftarrow E.\text{KeyGen}\\
\underline{\text{GETTAG}(c):}\\
\quad\text{return $M$.MAC}(k_m,c)\\
\underline{\text{CHECKTAG}(c,t):}\\
\quad \text{return}\ t\stackrel{?}{=}\textit{M}.\text{MAC}(k_m,c)\\\hline
\end{array}
\quad
\begin{array}{l}
\text{The operations of the}\\
\text{MAC scheme have been}\\
\text{factored out in terms of}\\
\text{$\mathcal{L}_{\text{mac-real}}^M$. Notably, in the}\\
\text{DEC subroutine the condition}\\
\text{“$t\neq M.\text{MAC}(k_M,c)$”}\\
\text{has been replaced with}\\
\text{“not CHECKTAG$(c,t)$”}\\
\end{array}
$$ 

$$
\def\arraystretch{1.5}
\begin{array}{|l|}\hline
k_e\leftarrow E.\text{KeyGen}\\
S:=\emptyset\\
\underline{\text{EAVESDROP}(m_L,m_R):}\\
\quad \text{if}\ |m_L|\neq |m_R|\\
\qquad\text{return null}\\
\quad c:=E.\text{Enc}(k_e,m_L)\\
\quad t:=\text{GETTAG}(c)\\
\quad S:=S\cup\{(c,t)\}\\
\quad \text{return}\ (c,t)\\
\underline{\text{Dec}(c,t):}\\
\quad \text{if}\ (c,t)\in S\\
\qquad \text{return null}\\
\quad \text{if}\ \text{not CHECKTAG}(c,t)\\
\qquad \text{return \textcolor{brown}{err}}\\
\quad \text{return $E$.Dec}(k_e,c)\\\hline
\end{array}
\diamond
\begin{array}{|l|}\hline
\qquad \qquad\mathcal{L}_{\text{mac-real}}^M\\\hline
k_m\leftarrow M.\text{KeyGen}\\
\colorbox{Yellow}{$\mathcal{T}=\emptyset$}\\
\underline{\text{GETTAG}(c):}\\
\quad t:=M.\text{MAC}(k_m,c)\\
\quad \colorbox{Yellow}{$\mathcal{T}:=\mathcal{T}\cup\{(c,t)\}$}\\
\quad\text{return}\ t\\
\underline{\text{CHECKTAG}(c,t):}\\
\quad \text{return}\ \colorbox{Yellow}{$(c,t)\stackrel{?}{\in}\mathcal{T}$}\\\hline
\end{array}
\quad
\begin{array}{l}
\text{We have applied the security of the}\\
\text{MAC scheme, and replaced $\mathcal{L}_{\text{mac-real}}$}\\
\text{with $\mathcal{L}_{\text{mac-fake}}.$}\\
\end{array}
$$

  

$$
\def\arraystretch{1.5}
\begin{array}{|l|}\hline
k_e\leftarrow E.\text{KeyGen}\\
\colorbox{Yellow}{$k_m\leftarrow M.\text{KeyGen}$}\\
\colorbox{Yellow}{$\mathcal{T}:=\emptyset$}\\
S:=\emptyset\\
\underline{\text{EAVESDROP}(m_L,m_R):}\\
\quad \text{if}\ |m_L|\neq |m_R|\\
\qquad\text{return null}\\
\quad c:=E.\text{Enc}(k_e,m_L)\\
\quad t:=\colorbox{Yellow}{$M.\text{MAC}(k_m,c)$}\\
\quad \colorbox{Yellow}{$\mathcal{T}:=\mathcal{T}\cup\{(c,t)\}$}\\
\quad S:=S\cup\{(c,t)\}\\
\quad \text{return}\ (c,t)\\
\underline{\text{DEC}(c,t):}\\
\quad \text{if}\ (c,t)\in S\\
\qquad \text{return null}\\
\quad \text{if}\ \colorbox{Yellow}{$(c,t)\notin \mathcal{T}:$}\\
\qquad \text{return \textcolor{brown}{err}}\\
\quad \text{return $E$.Dec}(k_e,c)\\\hline
\end{array}
\quad
\begin{array}{l}
\text{We have inlined the $\mathcal{L}_{\text {mac-fake }}$ library. This library keeps track}\\
\text{of a set $\mathcal{S}$ of values for the purpose of the CCA interface, but}\\
\text{also a set $\mathcal{T}$ of values for the purposes of the MAC. However, it}\\
\text{is clear from the code of this library that $\mathcal{S}$ and $\mathcal{T}$ always have}\\
\text{the same contents.}\\
\\
\text{Therefore, the two conditions " $(c, t) \in \mathcal{S}$ " and " $(c, t) \notin \mathcal{T}$ " in the}\\
\text{DEC subroutine are $exhaustive!$ The final line of $\mathrm{DEC}$ is $unreachable$.}\\
\text{This hybrid highlights the intuitive idea that an adversary}\\
\text{can either query DEC with a ciphertext generated by EAVESDROP}\\
\text{(the $(c, t) \in \mathcal{S}$ case $)-$ in which case the response is null $-$ or}\\
\text{with a different ciphertext $-$ in which case the response will be}\\
\text{$\textcolor{brown}{\text{err}}$ since the MAC will not verify.}\\
\end{array}
$$

      

$$
\def\arraystretch{1.5}
\begin{array}{|l|}\hline
k_e\leftarrow E.\text{KeyGen}\\
k_m\leftarrow M.\text{KeyGen}\\
S:=\emptyset\\
\underline{\text{EAVESDROP}(m_L,m_R):}\\
\quad \text{if}\ |m_L|\neq |m_R|\\
\qquad\text{return null}\\
\quad c:=E.\text{Enc}(k_e,m_L)\\
\quad t:=M.\text{MAC}(k_m, c)\\
\quad S:=S\cup\{(c,t)\}\\
\quad \text{return}\ (c,t)\\
\underline{\text{Dec}(c,t):}\\
\quad \text{if}\ (c,t)\in S\\
\qquad \text{return null}\\
\quad \text{if}\ (c,t)\notin \colorbox{Yellow}{$\mathcal{S}:$}\\
\qquad \text{return \textcolor{brown}{err}}\\
\quad \text{// unreachable}\\\hline
\end{array}
\begin{array}{l}
\text{The unreachable statement has been removed and the redundant}\\
\text{variables $S$ and $\mathcal{T}$ have been unified. Note that this hybrid library}\\
\text{never uses E.Dec, making it possible to express its use of}\\
\text{the $E$ encryption scheme in terms of $\mathcal{L}_{\text{cpa-L}}$.}\\
\end{array}
$$

   

$$
\def\arraystretch{1.5}
\begin{array}{|l|}\hline
k_m\leftarrow M.\text{KeyGen}\\
S:=\emptyset\\
\underline{\text{EAVESDROP}(m_L,m_R):}\\
\quad \text{if}\ |m_L|\neq |m_R|\\
\qquad\text{return null}\\
\quad c:=\colorbox{Yellow}{$\text{CPA.EAVESDROP}(m_L,m_R)$}\\
\quad t:=M.\text{MAC}(k_m,c)\\
\quad S:=S\cup\{(c,t)\}\\
\quad \text{return}\ (c,t)\\
\underline{\text{DEC}(c,t):}\\
\quad \text{if}\ (c,t)\in S\\
\qquad \text{return null}\\
\quad \text{if}\ (c,t)\notin \mathcal{S}:\\
\qquad \text{return \textcolor{brown}{err}}\\\hline
\end{array}
\diamond
\begin{array}{|l|}\hline
\qquad \qquad \quad\mathcal{L}_{\text{cpa-L}}^E\\\hline
k_e\leftarrow E.\text{KeyGen}\\
\underline{\text{CPA.EAVESDROP}(m_L,m_R):}\\
\quad c:=E.\text{Enc}(k_e,m_L) \\
\quad \text{return}\ c\\\hline
\end{array}
\begin{array}{l}
\text{The statements involving}\\
\text{the encryption}\\
\text{scheme $E$ have been}\\
\text{ factored out in terms}\\
\text{of $\mathcal{L}_{\text{cpa-L}}$.}
\end{array}
$$

  

We have now reached the half-way point of the proof. The proof proceeds by replacing $\mathcal{L}_{\text {cpa-L }}$ with $\mathcal{L}_{\text {cpa-R }}$ (so that $m_{R}$ rather than $m_{L}$ is encrypted), applying the same modifications as before (but in reverse order), to finally arrive at $\mathcal{L}_{\text {cca-R. }}$ The repetitive details have been omitted, but we mention that when listing the same steps in reverse, the changes appear very bizarre indeed. For instance, we add an unreachable statement to the DEC subroutine; we create a redundant variable $\mathcal{T}$ whose contents are the same as $\mathcal{S}$; we mysteriously change one instance of $\mathcal{S}$ (the condition of the second if-statement in DEC) to refer to the other variable $\mathcal{T}$. Of course, all of this is so that we can factor out the statements referring to the MAC scheme (along with $\mathcal{T}$ ) in terms of $\mathcal{L}_{\text {mac-fake }}$ and finally  replace  $\mathcal{L}_{\text {mac-fake }}$ with $\mathcal{L}_{\text {mac-real }}$.  $\ \ \blacksquare$

###  Exercises 
10.1. Consider the following MAC scheme, where F is a secure PRF with *in* = *out* = $\lambda$:

$$
\def\arraystretch{1.5}
\begin{array}{|ll|}\hline
\underline{\text{KeyGen:}} & \underline{\text{MAC}(k,m_1\|\cdots\|m_\ell):}//\textit{each $m_i$ is $\lambda$ bits}\\
\quad k\leftarrow \{\textcolor{brown}{0}.\textcolor{brown}{1}\}^\lambda & \quad m^*:=\textcolor{brown}{0}^\lambda\\
\quad \text{return}\ k & \quad \text{for}\ i=1\ \text{to}\ \ell:\\
& \qquad m^*:=m^*\oplus m_i\\
& \quad \text{return}\ G(k,m^*)\\\hline
\end{array}
$$

Show that the scheme is **not** a secure MAC. Describe a distinguisher and compute its advantage.

10.2. Consider the following MAC scheme, where $F $is a secure PRF with *in* = *out* = $\lambda$:

$$
\def\arraystretch{1.5}
\begin{array}{|ll|}\hline
\underline{\text{KeyGen:}} & \underline{\text{MAC}(k,m_1\|\cdots\|m_\ell):}//\textit{each $m_i$ is $\lambda$ bits}\\
\quad k\leftarrow \{\textcolor{brown}{0}.\textcolor{brown}{1}\}^\lambda & \quad t:=\textcolor{brown}{0}^\lambda\\
\quad \text{return}\ k & \quad \text{for}\ i=1\ \text{to}\ \ell:\\
& \qquad t:=t\oplus F(k,m_i)\\
& \quad \text{return}\ t\\\hline
\end{array}
$$

Show that the scheme is **not** a secure MAC. Describe a distinguisher and compute its advantage.
 
10.3. Suppose $\mathrm{MAC}$ is a secure $\mathrm{MAC}$ algorithm. Define a new algorithm $\mathrm{MAC}^{\prime}(k, m)=$ $\operatorname{MAC}(k, m) \| \operatorname{MAC}(k, m)$. Prove that $\mathrm{MAC}^{\prime}$ is also a secure MAC algorithm.

*Note*: MAC' cannot be a secure PRF. This shows that MAC security is different than PRF security.

10.4. Suppose $\mathrm{MAC}$ is a secure MAC scheme, whose outputs are $\ell$ bits long. Show that there is an efficient adversary that breaks MAC security (i.e., distinguishes the relevant libraries) with advantage $\Theta\left(1 / 2^{\ell}\right)$. This implies that MAC tags must be reasonably long in order to be secure.


10.5. Suppose we use $\mathrm{CBC}$ -MAC with message space $\mathcal{M}=\left(\{\textcolor{brown}{0}.\textcolor{brown}{1}\}^{\lambda}\right)^{*}$. In other words, a single MAC key will be used on messages of *any* length that is an exact multiple of the block length. Show that the result is **not** a secure MAC. Construct a distinguisher and compute its advantage.

>Hint: Request a MAC on two single-block messages, then use the result to forge the MAC of a two-block message.


$\star$ 10.6. Here is a different way to extend CBC-MAC for mixed-length messages, when the length of each message is known in advance. Assume that $F$ is a secure PRF with *in* = *out* = $\lambda$.

$$
\def\arraystretch{1.5}
\begin{array}{|l|}\hline
\underline{\text{NEWMAC}^F(k,m_1\|\cdots\|m_\ell)}\\
\quad k^*:=F(k,\ell)\\
\text{return CBCMAC}^F(k^*,m_1\|\cdots \|m_\ell\\\hline
\end{array}
$$

Prove that this scheme is a secure MAC for message space $\mathcal{M}=(\{\textcolor{brown}{0},\textcolor{brown}{1}^\lambda)^*$. You can use the fact that CBC-MAC is secure for messages of fixed-length.

10.7. Let $E$ be a CPA-secure encryption scheme and $M$ be a secure MAC. Show that the following encryption scheme (called encrypt & MAC) is **not** CCA-secure:

$$
\def\arraystretch{1.5}
\begin{array}{|lll|}\hline
\underline{E\&M.\text{KeyGen}:} &  \underline{E\&M.\text{Enc}((k_e,k_m),m):} &  \underline{E\&M.\text{Dec}((k_e,k_m),(c,t)):}\\
\quad k_e\leftarrow E.\text{KeyGen} & \quad c:=E.\text{Enc}(k_e,m)& \quad m:=E.\text{Dec}(k_e,c)\\
\quad k_m\leftarrow M.\text{KeyGen} & \quad t:=M.\text{MAC}(k_m,m) & \quad \text{if}\ t\neq M.\text{MAC}(k_m,m):\\
\quad \text{return}\ (k_e,k_m)& \quad \text{return}\  (c,t) &  \quad   \quad \text{return}\ \textcolor{brown}{\texttt{err}}\\
\quad & & \quad \text{return}\ m\\
\hline
\end{array}
$$

Describe a distinguisher and compute its advantage.

10.8. Let $E$ be a CPA-secure encryption scheme and $M$ be a secure MAC. Show that the following encryption scheme $\Sigma$ (which I call encrypt-and-encrypted-MAC) is **not** CCA-secure:

$$
\def\arraystretch{1.5}
\begin{array}{|lll|}\hline
\underline{\Sigma.\text{KeyGen}:} &  \underline{\Sigma.\text{Enc}((k_e,k_m),m):} &  \underline{\Sigma.\text{Dec}((k_e,k_m),(c,c')):}\\
\quad k_e\leftarrow E.\text{KeyGen} & \quad c:=E.\text{Enc}(k_e,m)& \quad m:=E.\text{Dec}(k_e,c)\\
\quad k_m\leftarrow M.\text{KeyGen} & \quad t:=M.\text{MAC}(k_m,m) & \quad t:=E.\text{Dec}(k_e,c')\\
\quad \text{return}\ (k_e,k_m)& \quad c'\leftarrow E.\text{Enc}(k_e,t) &\quad \text{if}\ t\neq M.\text{MAC}(k_m,m):\\
&\quad \text{return}\  (c,c') &  \quad \quad \text{return \textcolor{brown}{\texttt{err}}}\\
& & \quad \text{return}\ m\\\hline
\end{array}
$$
Describe a distinguisher and compute its advantage.

$\star 10.9 .$ In Construction $7.4,$ we encrypt one plaintext block into two ciphertext blocks. Imagine applying the Encrypt-then-MAC paradigm to this encryption scheme, but (erroneously) computing a MAC of only the second ciphertext block.

In other words, let $F$ be a PRF with $i n=$ out $=\lambda$, and let $M$ be a MAC scheme for message space $\{\textcolor{brown}{0},\textcolor{brown}{1}\}^{\lambda} .$ Define the following encryption scheme:

$$
\def\arraystretch{1.5}
\begin{array}{|lll|}\hline
\underline{\text{KeyGen}:} &  \underline{\text{Enc}((k_e,k_m),m):} &  \underline{\text{Dec}((k_e,k_m),(r,x,t)):}\\
\quad k_e\leftarrow \{\textcolor{brown}{0},\textcolor{brown}{1}\}^{\lambda}  & \quad r\leftarrow \{\textcolor{brown}{0},\textcolor{brown}{1}\}^{\lambda}& \quad \text{if}\ t\neq M.\text{MAC}(k_m,x):\\
\quad k_m\leftarrow M.\text{KeyGen} & \quad x:=F(k_e,r)\oplus m& \quad \text{return \textcolor{brown}{\texttt{err}}}\\
\quad \text{return}\ (k_e,k_m)& \quad t:=M.\text{MAC}(k_m,x) &\quad \text{else return}\ F(k_e,r)\oplus x\\
&\quad \text{return}\  (r,x,t) &  \\\hline
\end{array}
$$

Show that the scheme does **not** have CCA security. Describe a successful attack and compute its advantage.
>Hint: Suppose (r, x, t) and (r′, x′, t′) are valid encryptions, and consider Dec(($k_e$, $k_m$), (r′, x, t)) ⊕ x ⊕ x′.

10.10. When we combine different cryptographic ingredients (e.g., combining a CPA-secure encryption scheme with a MAC to obtain a CCA-secure scheme) we generally require the two ingredients to use *separate*, *independent keys*. It would be more convenient if the entire scheme just used a single $\lambda$ -bit key.
(a) Suppose we are using Encrypt-then-MAC, where both the encryption scheme and MAC have keys that are $\lambda$ bits long. Refer to the proof of security of Claim 12.5 and **describe where it breaks down** when we modify Encrypt-then-MAC to use the same key for both the encryption & MAC components:

$$
\def\arraystretch{1.5}
\begin{array}{|lll|}\hline
\underline{\text{KeyGen}:} &  \underline{\text{Enc}(\colorbox{Yellow}{$k$},m),:} &  \underline{\text{Dec}(\colorbox{Yellow}{$k$},(c,t))):}\\
\quad \colorbox{Yellow}{$k\leftarrow \{\textcolor{brown}{0},\textcolor{brown}{1}\}^{\lambda}$}  & \quad c:=E.\text{Enc}(\colorbox{Yellow}{$k$},m)& \quad \text{if}\ t\neq M.\text{MAC}(\colorbox{Yellow}{$k$},c):\\
\quad \text{return}\ k & \quad t:=M.\text{MAC}(\colorbox{Yellow}{$k$}, c)& \quad \text{return \textcolor{brown}{\texttt{err}}}\\
& \quad \text{return}\  (c,t) &\quad \text{return}\ E.\text{Dec}(\colorbox{Yellow}{$k$},c)\\\hline
\end{array}
$$

(b) While Encrypt-then-MAC requires independent keys $k_e$ and $k_m$ for the two components, show that they can both be *derived* from a single key using a PRF. In more detail, let $F$ be a PRF with *in* = 1 and out = $\lambda$. Prove that the following modified Encrypt-then-MAC construction is CCA-secure:
$$
\def\arraystretch{1.5}
\begin{array}{|lll|}\hline
\underline{\text{KeyGen}:} &  \underline{\text{Enc}(\colorbox{Yellow}{$k^*$},m),:} &  \underline{\text{Dec}(\colorbox{Yellow}{$k^*$},(c,t))):}\\
\quad \colorbox{Yellow}{$k^*\leftarrow \{\textcolor{brown}{0},\textcolor{brown}{1}\}^{\lambda}$}  & \quad \colorbox{Yellow}{$k_e:=F(k^*,\textcolor{brown}{0})$}&\quad \colorbox{Yellow}{$k_e:=F(k^*,\textcolor{brown}{0})$}\\
\quad \text{return}\ k^* &\quad  \colorbox{Yellow}{$k_m:=F(k^*,\textcolor{brown}{1})$}& \quad  \colorbox{Yellow}{$k_m:=F(k^*,\textcolor{brown}{1})$}\\
& \quad c:=E.\text{Enc}(k_e,m)&\quad \text{if}\ t\neq M.\text{MAC}(k_m,c):\\
&\quad t:=M.\text{MAC}(k_m,c) &\qquad \text{return \textcolor{brown}{\texttt{err}}}\\
&\quad \text{return}\ (c,t) &\quad \text{return}\ E.\text{Dec}(k_e,c)\\\hline
\end{array}
$$

You should not have to re-prove all the tedious steps of the Encrypt-then-MAC security proof. Rather, you should apply the security of the PRF in order to reach the *original* Encrypt-then-MAC construction, whose security we already proved (so you don’t have to repeat).



